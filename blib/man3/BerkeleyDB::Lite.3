.\" Automatically generated by Pod::Man version 1.15
.\" Thu Feb 27 13:19:47 2003
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Lite 3"
.TH Lite 3 "perl v5.6.1" "2003-02-27" "User Contributed Perl Documentation"
.UC
.SH "NAME"
BerkeleyDB::Lite \- Simplified Interface to BerkeleyDB
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use BerkeleyDB::Lite;
.Ve
.Sh "## Example 1"
.IX Subsection "## Example 1"
.Vb 4
\&  ## Create a Hashed database
\&  my $db = new BerkeleyDB::Lite::Hash
\&                home => 'zoo',
\&                filename => 'residents' ;
.Ve
.Vb 3
\&  $db->{Samson} = new Primate ;
\&  $db->{Cornelius} = new Primate ;
\&  $db->{Kaa} = new Reptile ;
.Ve
.Sh "## Example 2"
.IX Subsection "## Example 2"
.Vb 5
\&  ## Create a Btree database allowing duplicates and scalar values
\&  my $types = scalars BerkeleyDB::Lite::Btree
\&                home => 'zoo',
\&                filename => 'types',
\&                &duplicatekeys ;
.Ve
.Vb 3
\&  $types->{primate} = 'Samson' ;
\&  $types->{primate} = 'Cornelius' ;
\&  $types->{reptile} = 'Kaa' ;
.Ve
.Vb 2
\&  printf "%s\en", join ' ', $types->recordset{primate} ;
\&  ## prints: Samson Cornelius
.Ve
.Vb 3
\&  $types->delete( primate => 'Samson' ) ;
\&  printf "%s\en", join ' ', $types->recordset{primate} ;
\&  ## prints: Cornelius
.Ve
.Sh "## Example 3"
.IX Subsection "## Example 3"
.Vb 3
\&  ## Create a database of visitors
\&  ## Use a table with arbitrary keys
\&  ## Track visitors by date/timestamp
.Ve
.Vb 4
\&  $tickets = new BerkeleyDB::Lite::Btree
\&                home => 'zoo',
\&                filename => 'tickets',
\&                &incrementkeys ;
.Ve
.Vb 4
\&  ## Lexical Alternative
\&  # $tickets = lexical BerkeleyDB::Lite::Btree
\&  #             home => 'zoo',
\&  #             filename => 'tickets' ;
.Ve
.Vb 4
\&  $bytime = scalars BerkeleyDB::Lite::Btree
\&                home => 'zoo',
\&                filename => 'ticketsbytime',
\&                &duplicatekeys ;
.Ve
.Vb 5
\&  ## Process a new visitor in real time
\&  sub newvisitor {
\&        my $serial = $tickets->nextrecord() ;
\&        my $date = getdate() ;  ## not part of BerkeleyDB::Lite
\&        my $time = gettime() ;  ## not part of BerkeleyDB::Lite
.Ve
.Vb 4
\&        $tickets->{$serial} = { @_ } ;
\&        $bytime->{ "$date $time" } = $serial ;
\&        return $serial ;
\&        }
.Ve
.Vb 5
\&  ## Get a list of visitors on a certain date
\&  sub showvisitorsbydate {
\&        my $date = shift ;
\&        return $bytime->matchingvalues( $date ) ;
\&        }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
BerkeleyDB::Lite is an interface to Paul Marquess's BerkeleyDB
that provides simplified constructors, tied access to data, and 
methods for returning multiple record sets.
.Sh "Example 1"
.IX Subsection "Example 1"
BerkeleyDB::Lite maintains BerkeleyDB environment references
in a package variable hash keyed on the \fBhome\fR argument.  The 
basic BerkeleyDB::Lite constructor arguments define the 
BerkeleyDB environment and database.  When the constructor 
is called, a previously opened environment is used if 
available.  Otherwise, a new environment is created and is 
available to future constructor requests.
.PP
This version of BerkeleyDB::Lite creates all environment objects 
as concurrent data stores.  Transactional data storage is not 
currently integrated.
.PP
By default, BerkeleyDB::Lite is designed to marshall objects into a 
database using the \fBStorable\fR module.
.PP
Example 1 shows a simple application that illustrates both of 
these features.  The constructor is called with the minimum 
arguments to identify the environment and the database.
.PP
These few lines of code are sufficient to add persistent object 
support to an application.
.Sh "Example 2"
.IX Subsection "Example 2"
One of Berkeley's most appealing features is support for 
duplicate keys.  This feature enables a programmer to use 
persistent arrays, where elements can be accessed, added, 
and deleted without marshalling.
.PP
Example 2 uses the \fBscalars\fR constructor which disables the 
automatic serialization of record access.  Otherwise, if the 
\&\fBnew\fR constructor is used, scalars will be returned as scalar 
references, regardless of how they are stored.
.PP
\&\fB&duplicatekeys\fR is a subroutine that returns a pair of 
constants as a shortcut.  The constants are defined in the 
BerkeleyDB module.
.PP
The \fBrecordset\fR method returns a stored list from the database.  
This method is available to both BerkeleyDB::Lite::Btree and
BerkeleyDB::Lite::Hash classes.
.PP
The \fBdelete\fR method is used to delete an element from the list.  
Since BerkeleyDB::Lite adheres to the \fBTie\fR interface, the 
\&\fBdelete function\fR can normally used to remove stored objects.  
The \fBdelete method\fR should be used on databases with duplicate 
keys to avoid indeterminate results.
.PP
BerkeleyDB returns the status of a delete operation.  This 
feature can be used to delete an entire list using the following 
idiom:
.PP
.Vb 1
\&  while ( ! delete $types->{primate} ) {}
.Ve
A BerkeleyDB database configured for duplicate keys also allows 
duplicate key/value pairs.  For most one-to-many data sets, 
key/value pairs should be unique.  This issue has not been 
completely resolved.  Presently, the workaround is to import a 
retrieved list into a hash structure:
.PP
.Vb 2
\&  %unique = map { $_ => 1 } $types->recordset('primate') ;
\&  keys %unique ;
.Ve
However, care should be taken when deleting elements.  The 
delete method for duplicate keys should almost always be 
invoked using an idiom similar to the one above:
.PP
.Vb 1
\&  while ( ! $types->delete( primate => 'samson' ) ) {}
.Ve
Another source of problems occurs when using the \fBdelete\fR 
method on databases containing objects.  In this case, the 
second argument may refer to an object that does not exactly 
match the stored value.  The following code illustrates this 
difficulty:
.PP
.Vb 5
\&  my $cats = new BerkeleyDB::Lite::Btree(
\&                home => 'zoo',
\&                filename => 'cats',
\&                &duplicatekeys,
\&                ) ;
.Ve
.Vb 4
\&  my $Felix = new BigCat dinner => 'antelope' ;
\&  $cats->{lion} = $Felix ;
\&  $Felix->{dinner} = 'gazelle' ;
\&  $cats->delete( lion => $Felix ) ;             ## fails
.Ve
This problem also occurs because the results of the 
marshalling operation differ depending on whether numbers 
are interpreted as integers, floats, or strings.  Thus an 
object's value may change merely as a result of its 
context.  The following example illustrates the situation:
.PP
.Vb 6
\&  $weight = '300 lbs.' ;
\&  $weight =~ s/\eD//g ;
\&  my $Felix = new BigCat( weight => $weight ) ; ## member as string
\&  $cats->{lion} = $Felix ;
\&  $cats->delete( lion => $Felix )               ## operation fails
\&                if $Felix->{weight} > 200 ;     ## member as integer
.Ve
.Sh "Example 3"
.IX Subsection "Example 3"
Example 3 shows a few additional features helpful to 
developers accustomed to relational databases.  These 
features take advantage of the \fBBtree\fR database capabilities, 
and are not available to BerkeleyDB::Lite::Hash objects.
.PP
The \fBnextrecord\fR method of BerkeleyDB::Lite::Btree returns 
a new unique key.  Each \fBnextrecord\fR call creates a new 
blank record to avoid race conditions, and returns the new 
key.  This method creates a key by adding 1 to the last 
record.  In order to ensure that the last record contains 
the highest valued key, use the \fB&incrementkeys\fR argument 
to the BerkeleyDB::Lite::Btree constructor.  The 
\&\fB&incrementkeys\fR function is a shortcut that returns a 
\&\s-1CODE\s0 constant that forces numerical Btree sorting.
.PP
There is a significant disadvantage to databases created 
using the \fB&incrementkeys\fR argument.  The resulting 
databases are incompatible with SleepyCat utilities such as 
\&\fBdb_dump\fR and \fBdb_verify\fR.  As an alternative, 
\&\fBnextrecord\fR can be called as a method from the
BerkeleyDB::Lite::Btree::Lexical subclass.  This subclass 
functions identically, but the numerical keys are stored 
as zero padded strings.  Therefore, a restriction on 
\&\fBLexical\fR subclass databases is that keys must be 
numerically less than 10,000,000,000.
.PP
The \fBlexical\fR constructor to the BerkeleyDB::Lite::Btree 
class is synonymous with the \fBnew\fR constructor to the 
BerkeleyDB::Lite::Btree::Lexical subclass.
.PP
BerkeleyDB::Lite also implements another nice Berkeley
feature: partial string matching.  The methods 
\&\fBmatchingkeys\fR, \fBmatchingvalues\fR, and \fBsearchset\fR 
all return a set of records whose keys begin with a 
common substring.
.PP
For example, if keys are defined with the following 
format: \*(L"2002\ Jul\ 14\ 15:30\*(R", the following data can 
be returned:
.PP
.Vb 2
\&  ## All records for the year
\&  @annually = $bytime->matchingkeys('2002 ') ;
.Ve
.Vb 2
\&  ## All records for the month
\&  @monthly = $bytime->matchingvalues('2002 Jul ') ;
.Ve
.Vb 2
\&  ## All records for the day
\&  %daily = $bytime->searchset('2002 Jul 14 ') ;
.Ve
\&\fBmatchingkeys\fR returns an array of the matching records' 
keys.  \fBmatchingvalues\fR returns an array of the matching 
records' values.  Unforeseen confusion may result from the 
method name \fBmatchingvalues\fR\- the returned records have 
matching keys, but the record values are returned.
.PP
\&\fBsearchset\fR returns the matching records as key/value pairs 
that can populate an associative array as shown.  However, 
using an associative array is pointless if the 
database contains duplicate keys.  The following code is an 
effective technique for capturing the results of this type 
of search:
.PP
.Vb 3
\&    foreach ( $bytime->matchingkeys( '2002 Jul 14', &uniquekeys ) ) {
\&        $daily{ $_ } = [ $bytime->recordset( $_ ) ] ;
\&        }
.Ve
\&\fB&uniquekeys\fR returns a constant that is used primarily as 
an argument to the \fBmatchingkeys\fR method to filter duplicate 
results from the database.  When this argument is passed to 
the \fB&searchset\fR method, the values in the key/value pairs 
indicate a record count.  \fB&uniquekeys\fR cannot be used with 
the \fBmatchingvalues\fR method.
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
&duplicatekeys
&incrementkeys
&uniquepairs
&uniquekeys
.SH "AUTHOR"
.IX Header "AUTHOR"
Jim Schueler, <jschueler@tqis.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the Storable manpage
the BerkeleyDB manpage
\&\fIhttp://www.sleepycat.com\fR
